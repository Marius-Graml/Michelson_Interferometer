# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'realtime_plot_screen.ui'
#
# Created by: PyQt5 UI code generator 5.15.7
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from pyqtgraph import PlotWidget
from basic_osc_operations import get_one_ch_data
from filter_code import fir_low_pass
from demodulation_code import demodulate
import pyqtgraph as pg
import pandas as pd
import numpy as np

class Ui_Plot_window(object):
    def __init__(self, data_collector):
        self.data_collector = data_collector

    def setupUi(self, Plot_window):
        Plot_window.setObjectName("Plot_window")
        Plot_window.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(Plot_window)
        self.centralwidget.setObjectName("centralwidget")
        self.splitter = QtWidgets.QSplitter(self.centralwidget)
        self.splitter.setGeometry(QtCore.QRect(20, 10, 751, 241))
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setObjectName("splitter")
        self.plot_window_1 = PlotWidget(self.splitter)
        self.plot_window_1.setObjectName("plot_window_1")
        self.plot_window_2 = PlotWidget(self.splitter)
        self.plot_window_2.setObjectName("plot_window_2")
        self.splitter_2 = QtWidgets.QSplitter(self.centralwidget)
        self.splitter_2.setGeometry(QtCore.QRect(20, 260, 751, 231))
        self.splitter_2.setOrientation(QtCore.Qt.Horizontal)
        self.splitter_2.setObjectName("splitter_2")
        self.plot_window_3 = PlotWidget(self.splitter_2)
        self.plot_window_3.setObjectName("plot_window_3")
        self.plot_window_4 = PlotWidget(self.splitter_2)
        self.plot_window_4.setObjectName("plot_window_4")
        self.splitter_3 = QtWidgets.QSplitter(self.centralwidget)
        self.splitter_3.setGeometry(QtCore.QRect(20, 520, 751, 41))
        self.splitter_3.setOrientation(QtCore.Qt.Horizontal)
        self.splitter_3.setObjectName("splitter_3")
        self.start_plot_button = QtWidgets.QPushButton(self.splitter_3)
        self.start_plot_button.setObjectName("start_plot_button")
        self.stop_plot_button = QtWidgets.QPushButton(self.splitter_3)
        self.stop_plot_button.setObjectName("stop_plot_button")
        self.append_checkbox = QtWidgets.QCheckBox(self.centralwidget)
        self.append_checkbox.setGeometry(QtCore.QRect(620, 500, 71, 20))
        self.append_checkbox.setObjectName("append_checkbox")
        self.error_label = QtWidgets.QLabel(self.centralwidget)
        self.error_label.setGeometry(QtCore.QRect(20, 560, 371, 16))
        self.error_label.setStyleSheet("color: rgb(255, 0, 0);")
        self.error_label.setText("")
        self.error_label.setObjectName("error_label")
        self.reset_button = QtWidgets.QPushButton(self.centralwidget)
        self.reset_button.setGeometry(QtCore.QRect(700, 500, 71, 20))
        self.reset_button.setObjectName("reset_button")
        Plot_window.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(Plot_window)
        self.statusbar.setObjectName("statusbar")
        Plot_window.setStatusBar(self.statusbar)
        self.retranslateUi(Plot_window)
        QtCore.QMetaObject.connectSlotsByName(Plot_window)

        # Set background to white
        window_list = [self.plot_window_1, self.plot_window_2, self.plot_window_3, self.plot_window_4]
        for window in window_list:
            window.setBackground('w')

        # PlotItem list
        plotItem_list = [window.getPlotItem() for window in window_list]

        # Set axis labels, grid and title
        title_list = ['Oscilloscope output', 'Demodulated signal', 'Filtered signal', 'PID output']
        for n, plot_handle in enumerate(plotItem_list):
            plot_handle.setLabel(axis='bottom', text='time [ms]')
            plot_handle.setLabel(axis='left', text='Voltage [V]')
            plot_handle.showGrid(x =True, y=True)
            plot_handle.setTitle(title_list[n])

        # Initialize timer
        self.timer = QtCore.QTimer()

        # Set checkbox
        self.append_checkbox.setChecked(True)

        # Buttons
        self.start_plot_button.clicked.connect(self.start_plot)

        # Others
        self.osc_input_collector = []

    def retranslateUi(self, Plot_window):
        _translate = QtCore.QCoreApplication.translate
        Plot_window.setWindowTitle(_translate("Plot_window", "MainWindow"))
        self.start_plot_button.setText(_translate("Plot_window", "Start plot"))
        self.stop_plot_button.setText(_translate("Plot_window", "Stop plot"))
        self.append_checkbox.setText(_translate("Plot_window", "Appending"))
        self.reset_button.setText(_translate("Plot_window", "Reset"))

    def start_plot(self):
        if self.data_collector.osc_moku == None:
            self.error_label.setText('Please start oscilloscope first.')
        elif self.data_collector.dith_freq == None or self.data_collector.theta == None or self.data_collector.num_coeff == None or self.data_collector.cutoff == None:
            self.error_label.setText('Please insert all fields first.')
        else:
            # Set timer for plot update
            self.timer.setInterval(1000)
            self.timer.timeout.connect(self.update_plot)
            self.timer.start()

    def update_plot(self):

        self.stop_plot_button.clicked.connect(self.stop_plot)

        # Clear all windows
        window_list = [self.plot_window_1, self.plot_window_2, self.plot_window_3, self.plot_window_4]
        for window in window_list:
            window.clear()

        # Plot new data
        color_list = [pg.mkPen(color=(255, 0, 0)), pg.mkPen(color=(0, 255, 0)), pg.mkPen(color=(0, 0, 255)), pg.mkPen(color=(100, 100, 100))]
        signal_list = self.get_signals()
        for n, window in enumerate(window_list):
            window.plot(signal_list[n]['time']*1e3, signal_list[n]['ch'], pen=color_list[n]) # in ms

    def get_signals(self):
        # osc input
        # data = self.data_collector.osc_moku.get_data()
        # osc_input_df = get_one_ch_data(data, self.data_collector.input_ch_number)
        osc_input_df = self.get_osc_input(append=self.append_checkbox.isChecked())
        # demodulated signal
        demod_signal_df = demodulate(osc_input_df, self.data_collector.dith_freq, self.data_collector.theta)
        # filter ouput
        filter_output = fir_low_pass(demod_signal_df, self.data_collector.num_coeff, self.data_collector.cutoff, max_ripple = self.data_collector.max_ripple, min_attenuation =  self.data_collector.min_attenuation, fs=self.data_collector.fs, filtertype=self.data_collector.filtertype)
        # PID controller output
        pid_output = self.get_PID_output(filter_output)
        # return signal list
        return [osc_input_df, demod_signal_df, filter_output, pid_output]

    def stop_plot(self):
        self.timer.stop()

    def get_osc_input(self, append):
        fs = self.data_collector.fs
        self.reset_button.clicked.connect(self.clear_collector)
        self.append_checkbox.stateChanged.connect(self.clear_collector)

        data = self.data_collector.osc_moku.get_data()
        osc_input_df = get_one_ch_data(data, self.data_collector.input_ch_number)
        if append == True:
            data = osc_input_df['ch'].values.tolist()
            for item in data:
                self.osc_input_collector.append(item)

            osc_input = np.reshape(np.array(self.osc_input_collector), (-1,1))
            n_axis = np.arange(np.shape(osc_input)[0])
            t_axis = np.reshape(n_axis/fs, (-1,1)) # in s
            osc_input = np.concatenate((t_axis, osc_input), axis=1)
            osc_input_df = pd.DataFrame(osc_input, columns=['time', 'ch'])

        return osc_input_df

    def get_PID_output(self, filter_output):
        fs = self.data_collector.fs

        # Data: pd Dataframe with columns 'time' and 'channel'
        data = np.reshape(np.array(filter_output['ch']), (-1,1))
        output_data = np.zeros(np.shape(data))
        for n, sample_value in enumerate(data):
            output_data[n] = self.data_collector.pid(sample_value)
        n_axis = np.arange(np.shape(output_data)[0])
        t_axis = np.reshape(n_axis/fs, (-1,1)) # in s
        output = np.concatenate((t_axis, output_data), axis=1)

        output_df = pd.DataFrame(output, columns=['time', 'ch'])
        return output_df

    def clear_collector(self):
        self.osc_input_collector = []
